package xi_parser;
// A stub for a Xi CUP specification.

import java.util.*;

import java_cup.runtime.*;
import lexer.XiToken;
import lexer.XiLexer;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

parser code
{:
  XiLexer lexer;
:};

scan with
{:
return lexer.next_token();
:};

// You might want to add types to these declarations.
terminal XiToken
    ID,
    STRING_LIT,
    CHAR_LIT,
    INT_LIT,
    BOOL_LIT,
    INT_TYPE,
    BOOL_TYPE;

terminal XiToken
    UNDERSCORE,
    USE,
    IF,
    WHILE,
    ELSE,
    RETURN,
    LENGTH,

    EQ,
    MINUS,
    PLUS,
    NOT,
    MULT,
    HI_MULT,
    DIV,
    MOD,
    EQEQ,
    NEQ,
    GT,
    LT,
    GTEQ,
    LTEQ,
    AND,
    OR,
    UMINUS, //maybe not necessary

    COLON,
    SEMICOLON,
    COMMA,
    LPAREN,
    RPAREN,
    LBRAC,
    RBRAC,
    LCURL,
    RCURL,
    ERROR;

// You might want to add types to these declarations.
nonterminal SourceFile source;
nonterminal InterfaceFile interface;
nonterminal ProgramFile program;

nonterminal Pair annotated_var;
nonterminal Type basictype;
nonterminal Type type;
nonterminal Decl decl;
nonterminal Defn defn;
nonterminal UseInterface use_interface;
nonterminal Expr assignable;

nonterminal Expr expr;
nonterminal Expr binop;
nonterminal Expr unop;

nonterminal Stmt statement;
nonterminal Stmt return;
nonterminal Stmt block;

nonterminal ArrayList<Pair> annotated_varlist;
nonterminal ArrayList<Expr> exprlist;
nonterminal ArrayList<Stmt> stmtlist;
nonterminal ArrayList<UseInterface> importlist;
nonterminal ArrayList<Expr> assignablelist;
nonterminal ArrayList<Defn> defnlist;

precedence nonassoc UMINUS, NOT;
precedence left MULT, DIV, MOD, HI_MULT;
precedence left PLUS, MINUS;
precedence left LT, GT, LTEQ, GTEQ;
precedence left EQ, NEQ, EQEQ;
precedence left AND;
precedence left OR;
precedence left COMMA;

//TYPES

type ::=
  BOOL_TYPE:t {: RESULT = new Tvar("bool"); :}
| INT_TYPE:t {: RESULT = new Tvar("int"); :}
| type:t LBRAC RBRAC {: RESULT = new ListType(t); :}
| type:t LBRAC expr:e RBRAC {: RESULT = new ListType(t,e); :}
| type:t1 COMMA type:t2 {:
    ArrayList<Type> l = new ArrayList<>();
    l.add(t1);
    l.add(t2);
    RESULT = new TupleType(l); :} // TODO: need new nonterminal for this
;

annotated_varlist ::=
  annotated_var:a {:
    ArrayList<Pair<String,Type>> l = new ArrayList<>();
    l.add(a);
    RESULT = l; :}
| annotated_varlist:l COMMA annotated_var:a {: l.add(a); RESULT = l; :}
;

annotated_var ::=
  ID:i COLON type:t {:
    RESULT = new Pair<String,Type>((String) i.getValue(), t); :}
;

//DECLARATIONS AND DEFINITIONS
decl ::=
  ID:n LPAREN RPAREN {:
    ArrayList<Pair<String, Type>> l = new ArrayList<>();
    RESULT = new ProcedureDecl((String) n.getValue(), l); :}
| ID:n LPAREN RPAREN COLON type:t {:
    ArrayList<Pair<String, Type>> l = new ArrayList<>();
    RESULT = new FunctionDecl((String) n.getValue(), l, t); :}
| ID:n LPAREN annotated_varlist:p RPAREN {:
    RESULT = new ProcedureDecl((String) n.getValue(), p); :}
| ID:n LPAREN annotated_varlist:p RPAREN COLON type:t {:
    RESULT = new FunctionDecl((String) n.getValue(), p, t); :}
;

defn ::=
  ID:n LPAREN RPAREN block:b {:
    ArrayList<Pair<String, Type>> l = new ArrayList<>();
    RESULT = new ProcedureDefn((String) n.getValue(), l, b); :}
| ID:n LPAREN RPAREN COLON type:t block:b {:
    ArrayList<Pair<String, Type>> l = new ArrayList<>();
    RESULT = new FunctionDefn((String) n.getValue(), l, t, b); :}
| ID:n LPAREN annotated_varlist:p RPAREN block:b {:
    RESULT = new ProcedureDefn((String) n.getValue(), p, b); :}
| ID:n LPAREN annotated_varlist:p RPAREN COLON type:t block:b {:
    RESULT = new FunctionDefn((String) n.getValue(), p, t, b); :}
;

defnlist ::=
  defn:d {:
      ArrayList<Defn> l = new ArrayList<>();
      l.add(d);
      RESULT = l; :}
| defnlist:l defn:d {: l.add(d); RESULT = l; :}
;

//IMPORTS
use_interface ::=
  USE ID:i {: RESULT = new UseInterface((String) i.getValue()); :}
| USE ID:i SEMICOLON {: RESULT = new UseInterface((String) i.getValue()); :}
;

importlist ::=
  use_interface:i {:
      ArrayList<UseInterface> l = new ArrayList<>();
      l.add(i);
      RESULT = l; :}
| importlist:l use_interface:i {: l.add(i); RESULT = l; :}
;

//EXPRESSIONS
exprlist ::= //NOTE: THIS DOES NOT SUPPORT COMMAS AT THE END
  expr:e {:
       ArrayList<Expr> l = new ArrayList<>();
       l.add(e);
       RESULT = l; :}
| exprlist:l COMMA expr:e {: l.add(e); RESULT = l; :}
;

expr ::=
  binop:b {: RESULT = b; :}
| unop:u {: RESULT = u; :}
| BOOL_LIT:b {: RESULT = new BoolLiteralExpr(b.getValue()); :}
| INT_LIT:i {: RESULT = new IntLiteralExpr(i.getValue()); :}
| CHAR_LIT:c {: RESULT = new IntLiteralExpr(c.getValue()); :} // chars are really ints
| STRING_LIT:s {: RESULT = new ListLiteralExpr(s); :} // strings are really lists of ints
| ID:i {: RESULT = new IdExpr((String) i.getValue()); :}
| ID:i LPAREN exprlist RPAREN {:
    RESULT = new FunctionCallExpr((String) i.value, exprlist); :}
| ID:i LPAREN RPAREN {:
    RESULT = new FunctionCallExpr((String) i.value, new ArrayList<Expr>()); :}
| expr:e1 LBRAC expr:e2 RBRAC {: RESULT = new IndexExpr(e1, e2); :}
| LENGTH LPAREN expr:e RPAREN {: RESULT = new LengthExpr(e); :}
| LCURL exprlist:e RCURL {: RESULT = new ListLiteralExpr(e); :}
| LPAREN expr:e RPAREN {: RESULT = e; :}//grouping expressions
;

binop ::=
  expr:e1 AND:o expr:e2 {: RESULT = new BinopExpr(Binop.AND, e1, e2); :}
| expr:e1 OR:o expr:e2 {: RESULT = new BinopExpr(Binop.OR, e1, e2); :}
| expr:e1 PLUS:o expr:e2 {: RESULT = new BinopExpr(Binop.PLUS, e1, e2); :}
| expr:e1 MINUS:o expr:e2 {: RESULT = new BinopExpr(Binop.MINUS, e1, e2); :}
| expr:e1 DIV:o expr:e2 {: RESULT = new BinopExpr(Binop.DIV, e1, e2); :}
| expr:e1 MOD:o expr:e2 {: RESULT = new BinopExpr(Binop.MOD, e1, e2); :}
| expr:e1 MULT:o expr:e2 {: RESULT = new BinopExpr(Binop.MULT, e1, e2); :}
| expr:e1 HI_MULT:o expr:e2 {: RESULT = new BinopExpr(Binop.HI_MULT, e1, e2); :}
| expr:e1 EQEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.EQEQ, e1, e2); :}
| expr:e1 NEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.NEQ, e1, e2); :}
| expr:e1 GT:o expr:e2 {: RESULT = new BinopExpr(Binop.GT, e1, e2); :}
| expr:e1 LT:o expr:e2 {: RESULT = new BinopExpr(Binop.LT, e1, e2); :}
| expr:e1 GTEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.GTEQ, e1, e2); :}
| expr:e1 LTEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.LTEQ, e1, e2); :}
;

unop ::=
  MINUS expr:e {: RESULT = new UnopExpr(Unop.UMINUS, e); :}
| NOT expr:e {: RESULT = new UnopExpr(Unop.NOT, e); :}
;

//STATEMENTS

assignablelist ::= //NOTE: THIS DOES NOT SUPPORT COMMAS AT THE END
  assignable:a {:
      ArrayList<Expr> l = new ArrayList<>();
      l.add(a);
      RESULT = l; :}
| assignablelist:l COMMA assignable:a {: l.add(a); RESULT = l; :}
;

assignable ::= //enforces assignability of the left side expression
 UNDERSCORE {: RESULT = new UnderscoreExpr(); :}
| expr:e {: RESULT = e; :} //in semantic analysis need to make sure that left side does not begin with ( or {
;

statement ::=
  statement:s SEMICOLON {: RESULT = s; :}
| block:b {: RESULT b; :}
| assignable:a EQ expr:e {:
    ArrayList<Expr> l1 = new ArrayList<>();
    l1.add(a);
    RESULT = l1;
    ArrayList<Expr> l2 = new ArrayList<>();
    l2.add(e);
    RESULT = l2;
    RESULT = new AssignStmt(l1, l2); :}
| assignablelist:a EQ exprlist:e {: RESULT = new AssignStmt(a, e); :}
| annotated_var:d EQ expr:e {:
    ArrayList<Pair<String,Type>> l1 = new ArrayList<>();
    l1.add(d);
    ArrayList<Expr> l2 = new ArrayList<>();
    l2.add(e);
    RESULT = new DeclAssignStmt(l1, l2); :}
| annotated_varlist:d EQ exprlist:e {:
    RESULT = new DeclAssignStmt(d, e); :}
| annotated_var:d {:
    ArrayList<Pair<String,Type>> l = new ArrayList<>();
    l.add(d);
    RESULT = new DeclStmt(l); :}
| annotated_varlist:d {: RESULT = new DeclStmt(d); :}
| ID:i LPAREN exprlist RPAREN {:
    RESULT = new ProcedureCallExpr((String) i.value, exprlist); :}
| ID:i LPAREN RPAREN {:
    RESULT = new ProcedureCallExpr((String) i.value, new ArrayList<Expr>()); :}
| IF expr:e statement:s {: RESULT = new IfStmt(e,s); :}
| IF expr:e statement:s1 ELSE statement:s2 {:
    RESULT = new IfElseStmt(e,s1,s2); :}
| WHILE expr:e statement:s {: RESULT = new WhileStmt(e,s); :}
;

return ::= //enforces return statements being at the end of blocks + cannot replace blocks
  RETURN {: RESULT = new ProcedureReturnStmt(); :}
| RETURN expr:e {: RESULT = new FunctionReturnStmt(e); :}
| return:r SEMICOLON {: RESULT = r; :}
;

stmtlist ::=
  statement:s {:
     ArrayList<Stmt> l = new ArrayList<>();
     l.add(s);
     RESULT = l; :}
| stmtlist:l statement:s {: l.add(s); RESULT = l; :}
;

block ::=
  LCURL stmtlist:l RCURL {: RESULT = new BlockStmt(l); :}
| LCURL stmtlist:l return:r RCURL {: l.append(r); RESULT = new BlockStmt(l); :}
| LCURL RCURL {: RESULT = new BlockStmt(); :}
;

//HIGHEST LEVEL
source ::=
  interface:i {: RESULT = (SourceFile) i; :}
| program:p {: RESULT = (SourceFile) p; :}
;

interface ::=
  decl:d {:
      ArrayList<Decl> l = new ArrayList<>();
      l.add(d);
      RESULT = l; :}
| interface:i decl:d {: i.addDecl(d); RESULT = i; :}
;

program ::= importlist defnlist {:
    RESULT = new ProgramFile(importlist, defnlist); :}
;









