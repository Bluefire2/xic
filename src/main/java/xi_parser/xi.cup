package xi_parser;
// A stub for a Xi CUP specification.

import ast.*;
import lexer.XiLexer;
import lexer.XiToken;
import lexer.LexicalErrorException;
import polyglot.util.Pair;

import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

import lexer.XiTokenFactory;
import java_cup.runtime.Symbol;

parser code
{:
    XiLexer lexer;

    public XiParser (XiLexer l, XiTokenFactory xtf) {
        super(l,xtf);
        this.lexer = l;
    }

    public void syntax_error(Symbol s) {
        if (s instanceof XiToken) {
            XiToken t = (XiToken) s;
            String message = String.format("%s error:Unexpected token %s",
                                                t.getLeft(), t.getValue());
            throw new SyntaxErrorException(message);
        }
    }
:};

scan with
{:
    Symbol s = lexer.next_token();
    XiToken t = (XiToken) s;
    if (t.sym == sym.ERROR)
        throw new LexicalErrorException(t.toString());
    // no lexer error, pass on the symbol
    return s;
:};

terminal String ID;
terminal String STRING_LIT;
terminal Character CHAR_LIT;
terminal Long INT_LIT;
terminal Boolean BOOL_LIT;
terminal INT_TYPE, BOOL_TYPE;

terminal
    UNDERSCORE,
    USE,
    IF,
    WHILE,
    ELSE,
    RETURN,
    LENGTH,

    EQ,
    MINUS,
    PLUS,
    NOT,
    MULT,
    HI_MULT,
    DIV,
    MOD,
    EQEQ,
    NEQ,
    GT,
    LT,
    GTEQ,
    LTEQ,
    AND,
    OR,
    UMINUS, //maybe not necessary

    COLON,
    SEMICOLON,
    COMMA,
    LPAREN,
    RPAREN,
    LBRAC,
    RBRAC,
    LCURL,
    RCURL,
    ERROR;

nonterminal SourceFile source;
nonterminal InterfaceFile interface;
nonterminal ProgramFile program;

nonterminal Pair annotated_var;
nonterminal TypeTTau type;
nonterminal FuncDecl func_decl;
nonterminal FuncDefn func_defn;
nonterminal UseInterface use_interface;

nonterminal Expr expr;
nonterminal Assignable assignable;

nonterminal Stmt statement, matchedstmt, unmatchedstmt;
nonterminal Stmt return;
nonterminal Stmt block;

nonterminal ArrayList<Pair<String, TypeTTau>> annotated_varlist;
nonterminal ArrayList<TypeDecl> underscore_varlist;
nonterminal ArrayList<Expr> exprlist;
nonterminal ArrayList<Stmt> stmtlist;
nonterminal ArrayList<UseInterface> importlist;
nonterminal ArrayList<Assignable> assignablelist;
nonterminal ArrayList<FuncDefn> func_defnlist;
nonterminal ArrayList<TypeTTau> typelist;
nonterminal ArrayList<Expr> indices;

precedence left COMMA;
precedence left OR;
precedence left AND;
precedence left NEQ, EQEQ;
precedence left LT, GT, LTEQ, GTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, HI_MULT;
precedence nonassoc UMINUS, NOT;
precedence left LBRAC, RBRAC, LPAREN, RPAREN;


start with source;

//TYPES

type ::=
  BOOL_TYPE:t {: RESULT = new TypeTTauBool(); :}
| INT_TYPE:t {: RESULT = new TypeTTauInt(); :}
| type:t LBRAC RBRAC {:
    if (t instanceof TypeTTauArray){
        TypeTTauArray curr = (TypeTTauArray) t;
        while (curr.getTypeTTau() instanceof TypeTTauArray){
            curr = (TypeTTauArray) curr.getTypeTTau();
        }
        curr.setTypeTTau(new TypeTTauArray(curr.getTypeTTau()));
        RESULT = t;
    } else {
        RESULT = new TypeTTauArray(t);
    } :}
| type:t LBRAC expr:e RBRAC {:
    if (t instanceof TypeTTauArray){
        TypeTTauArray curr = (TypeTTauArray) t;
        while (curr.getTypeTTau() instanceof TypeTTauArray){
            curr = (TypeTTauArray) curr.getTypeTTau();
        }
        curr.setTypeTTau(new TypeTTauArray(curr.getTypeTTau(),e));
        RESULT = t;
    } else {
        RESULT = new TypeTTauArray(t,e);
    } :}
;

typelist ::=
  type:t {:
    ArrayList<TypeTTau> l = new ArrayList<>();
    l.add(t);
    RESULT = l; :}
  | typelist:l COMMA type:t {: l.add(t); RESULT = l; :}
;

annotated_varlist ::=
  annotated_var:a {:
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    l.add(a);
    RESULT = l; :}
| annotated_varlist:l COMMA annotated_var:a {: l.add(a); RESULT = l; :}
;

annotated_var ::=
  ID:i COLON type:t {: RESULT = new Pair<String, TypeTTau>(i, t); :}
;

// TODO: IDEA says that p -> New TypeDeclVar(p) can be just a function, which
//  one?
underscore_varlist ::=
  annotated_varlist:l COMMA UNDERSCORE {:
    List<TypeDecl> newl = l.stream()
        .map(p -> new TypeDeclVar(p)).collect(Collectors.toList());
    newl.add(new TypeDeclUnderscore()); RESULT = new ArrayList<>(newl); :}
| UNDERSCORE COMMA annotated_varlist:l {:
    List<TypeDecl> newl = l.stream()
        .map(p -> new TypeDeclVar(p)).collect(Collectors.toList());
    newl.add(0, new TypeDeclUnderscore()); RESULT = new ArrayList<>(newl); :}
| underscore_varlist:l COMMA UNDERSCORE {:
    l.add(new TypeDeclUnderscore()); RESULT = l; :}
| underscore_varlist:l COMMA annotated_var:a {:
    l.add(new TypeDeclVar(a)); RESULT = l; :}
;

//FUNCTION DECLARATIONS AND DEFINITIONS
// Need to differentiate type and typelist with COMMA, otherwise possible
// shift-shift conflict
func_decl ::=
  ID:n LPAREN RPAREN {:
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    RESULT = new FuncDecl(n, l, nleft, nright); :}
| ID:n LPAREN RPAREN COLON type:t {:
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    RESULT = new FuncDecl(n, l, t, nleft, nright); :}
| ID:n LPAREN RPAREN COLON type:t1 COMMA typelist:t2 {:
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    t2.add(0, t1);
    RESULT = new FuncDecl(n, l, new TypeTList(t2), nleft, nright); :}
| ID:n LPAREN annotated_varlist:p RPAREN {:
    RESULT = new FuncDecl(n, p, nleft, nright); :}
| ID:n LPAREN annotated_varlist:p RPAREN COLON type:t {:
    RESULT = new FuncDecl(n, p, t, nleft, nright); :}
| ID:n LPAREN annotated_varlist:p RPAREN COLON type:t1 typelist:t2 {:
    t2.add(0, t1);
    RESULT = new FuncDecl(n, p, new TypeTList(t2), nleft, nright); :}
;

func_defn ::=
  ID:n LPAREN RPAREN block:b {:
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    RESULT = new FuncDefn(n, l, b, nleft, nright); :}
| ID:n LPAREN RPAREN COLON type:t block:b {:
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    RESULT = new FuncDefn(n, l, t, b, nleft, nright); :}
| ID:n LPAREN RPAREN COLON type:t1 COMMA typelist:t2 block:b {:
    t2.add(0, t1);
    ArrayList<Pair<String, TypeTTau>> l = new ArrayList<>();
    RESULT = new FuncDefn(n, l, new TypeTList(t2), b, nleft, nright); :}
| ID:n LPAREN annotated_varlist:p RPAREN block:b {:
    RESULT = new FuncDefn(n, p, b, nleft, nright); :}
| ID:n LPAREN annotated_varlist:p RPAREN COLON type:t block:b {:
    RESULT = new FuncDefn(n, p, t, b, nleft, nright); :}
| ID:n LPAREN annotated_varlist:p RPAREN COLON type:t1 COMMA typelist:t2 block:b {:
    t2.add(0, t1);
    RESULT = new FuncDefn(n, p, new TypeTList(t2), b, nleft, nright); :}
;

func_defnlist ::=
  func_defn:d {:
      ArrayList<FuncDefn> l = new ArrayList<>();
      l.add(d);
      RESULT = l; :}
| func_defnlist:l func_defn:d {: l.add(d); RESULT = l; :}
;

//IMPORTS
use_interface ::=
  USE ID:i {: RESULT = new UseInterface(i, ileft, iright); :}
| USE ID:i SEMICOLON {: RESULT = new UseInterface(i, ileft, iright); :}
;

importlist ::=
  use_interface:i {:
      ArrayList<UseInterface> l = new ArrayList<>();
      l.add(i);
      RESULT = l; :}
| importlist:l use_interface:i {: l.add(i); RESULT = l; :}
;

//EXPRESSIONS
exprlist ::= //NOTE: THIS DOES NOT SUPPORT COMMAS AT THE END
  expr:e {:
       ArrayList<Expr> l = new ArrayList<>();
       l.add(e);
       RESULT = l; :}
| exprlist:l COMMA expr:e {: l.add(e); RESULT = l; :}
;

expr ::=
  BOOL_LIT:b {: RESULT = new BoolLiteralExpr(b, bleft, bright); :}
| INT_LIT:i {: RESULT = new IntLiteralExpr(i, ileft, iright); :}
| CHAR_LIT:c {: RESULT = new IntLiteralExpr(c, cleft, cright); :} // chars are really ints
| STRING_LIT:s {: RESULT = new ArrayLiteralExpr(s, sleft, sright); :} // strings are really lists of ints
| ID:i {: RESULT = new IdExpr(i, ileft, iright); :}
| ID:i LPAREN exprlist:el RPAREN {:
    RESULT = new FunctionCallExpr(i, el, ileft, iright); :}
| ID:i LPAREN RPAREN {:
    RESULT = new FunctionCallExpr(i, new ArrayList<Expr>(), ileft, iright); :}
| expr:e1 LBRAC:l expr:e2 RBRAC {: RESULT = new IndexExpr(e1, e2, lleft, lright); :}
| LENGTH:l LPAREN expr:e RPAREN {: RESULT = new LengthExpr(e, lleft, lright); :}
| LCURL:l exprlist:e RCURL {: RESULT = new ArrayLiteralExpr(e, lleft, lright); :}
| LCURL:l exprlist:e COMMA RCURL {: RESULT = new ArrayLiteralExpr(e, lleft, lright); :}
| LCURL:l RCURL {: RESULT = new ArrayLiteralExpr(new ArrayList<Expr>(), lleft, lright); :}
| LPAREN expr:e RPAREN {: RESULT = e; :}//grouping expressions
| expr:e1 AND:o expr:e2 {: RESULT = new BinopExpr(Binop.AND, e1, e2, oleft, oright); :}
| expr:e1 OR:o expr:e2 {: RESULT = new BinopExpr(Binop.OR, e1, e2, oleft, oright); :}
| expr:e1 PLUS:o expr:e2 {: RESULT = new BinopExpr(Binop.PLUS, e1, e2, oleft, oright); :}
| expr:e1 MINUS:o expr:e2 {: RESULT = new BinopExpr(Binop.MINUS, e1, e2, oleft, oright); :}
| expr:e1 DIV:o expr:e2 {: RESULT = new BinopExpr(Binop.DIV, e1, e2, oleft, oright); :}
| expr:e1 MOD:o expr:e2 {: RESULT = new BinopExpr(Binop.MOD, e1, e2, oleft, oright); :}
| expr:e1 MULT:o expr:e2 {: RESULT = new BinopExpr(Binop.MULT, e1, e2, oleft, oright); :}
| expr:e1 HI_MULT:o expr:e2 {: RESULT = new BinopExpr(Binop.HI_MULT, e1, e2, oleft, oright); :}
| expr:e1 EQEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.EQEQ, e1, e2, oleft, oright); :}
| expr:e1 NEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.NEQ, e1, e2, oleft, oright); :}
| expr:e1 GT:o expr:e2 {: RESULT = new BinopExpr(Binop.GT, e1, e2, oleft, oright); :}
| expr:e1 LT:o expr:e2 {: RESULT = new BinopExpr(Binop.LT, e1, e2, oleft, oright); :}
| expr:e1 GTEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.GTEQ, e1, e2, oleft, oright); :}
| expr:e1 LTEQ:o expr:e2 {: RESULT = new BinopExpr(Binop.LTEQ, e1, e2, oleft, oright); :}
| MINUS:o expr:e {: RESULT = new UnopExpr(Unop.UMINUS, e, oleft, oright); :} %prec UMINUS
| NOT:o expr:e {: RESULT = new UnopExpr(Unop.NOT, e, oleft, oright); :}
;

//STATEMENTS

assignablelist ::= //NOTE: THIS DOES NOT SUPPORT COMMAS AT THE END
  assignable:a {:
    ArrayList<Assignable> l = new ArrayList<>();
    l.add(a);
    RESULT = l; :}
| assignablelist:l COMMA assignable:a {: l.add(a); RESULT = l; :}
;

assignable ::=
  UNDERSCORE:u {: RESULT = new UnderscoreAssignable(uleft, uright); :}
| ID:i {: RESULT = new IdAssignable(new IdExpr(i, ileft, iright), ileft, iright); :}
| ID:i indices:l {:
    Expr idx = new IdExpr(i, ileft, iright);
    for (Expr e: l){
        idx = new IndexExpr(idx,e, ileft, iright);
    }
    RESULT = new IndexAssignable(idx, ileft, iright);
    :}
;

indices ::=
  LBRAC expr:e RBRAC {: ArrayList<Expr> l = new ArrayList<>(); l.add(e); RESULT = l; :}
| indices:l LBRAC expr:e RBRAC {: l.add(e); RESULT = l; :}
;

matchedstmt ::=
  IF:i expr:e matchedstmt:s1 ELSE matchedstmt:s2 {:
    RESULT = new IfElseStmt(e,s1,s2, ileft, iright); :}
| WHILE:w expr:e matchedstmt:s {: RESULT = new WhileStmt(e,s, wleft, wright); :}
| block:b {: RESULT = b; :}
| assignablelist:a EQ exprlist:e {: RESULT = new AssignStmt(a, e, aleft, aright); :}
| underscore_varlist:d EQ exprlist:e {:
    RESULT = new DeclAssignStmt(d, e, dleft, dright); :}
| annotated_varlist:d {:
    List<TypeDeclVar> newd = d.stream()
        .map(p -> new TypeDeclVar(p)).collect(Collectors.toList());
    RESULT = new DeclStmt(newd, dleft, dright); :}
| annotated_varlist:d EQ exprlist:e {:
    List<TypeDecl> newd = d.stream()
        .map(p -> new TypeDeclVar(p)).collect(Collectors.toList());
    RESULT = new DeclAssignStmt(newd, e, dleft, dright); :}
| ID:i LPAREN exprlist:el RPAREN {:
    RESULT = new ProcedureCallStmt(i, el, ileft, iright); :}
| ID:i LPAREN RPAREN {:
    RESULT = new ProcedureCallStmt(i, new ArrayList<Expr>(), ileft, iright); :}
;


unmatchedstmt ::=
  IF:i expr:e unmatchedstmt:s {: RESULT = new IfStmt(e,s, ileft, iright); :}
| IF:i expr:e matchedstmt:s {: RESULT = new IfStmt(e,s, ileft, iright); :}
| WHILE:w expr:e unmatchedstmt:s {: RESULT = new WhileStmt(e,s, wleft, wright); :}
;

statement ::=
  matchedstmt:m {: RESULT = m; :}
| unmatchedstmt:u {: RESULT = u; :}
;

return ::= //enforces return statements being at the end of blocks + cannot replace blocks
  RETURN:r {: RESULT = new ReturnStmt(rleft, rright); :}
| RETURN:r exprlist:e {: RESULT = new ReturnStmt(e, rleft, rright); :}
| RETURN:r SEMICOLON {: RESULT = new ReturnStmt(rleft, rright); :}
| RETURN:r exprlist:e SEMICOLON {: RESULT = new ReturnStmt(e, rleft, rright); :}
;

stmtlist ::=
  statement:s {:
     ArrayList<Stmt> l = new ArrayList<>();
     l.add(s);
     RESULT = l; :}
| stmtlist:l SEMICOLON statement:s {: l.add(s); RESULT = l; :}
| stmtlist:l statement:s {: l.add(s); RESULT = l; :}
;

block ::=
  LCURL:c return:r RCURL {: RESULT = new BlockStmt(cleft, cright); :}
| LCURL:c stmtlist:l RCURL {: RESULT = new BlockStmt(l, cleft, cright); :}
| LCURL:c stmtlist:l return:r RCURL {: l.add(r); RESULT = new BlockStmt(l, cleft, cright); :}
| LCURL:c stmtlist:l SEMICOLON RCURL {: RESULT = new BlockStmt(l, cleft, cright); :}
| LCURL:c stmtlist:l SEMICOLON return:r RCURL {: l.add(r); RESULT = new BlockStmt(l, cleft, cright); :}
| LCURL:c RCURL {: RESULT = new BlockStmt(cleft, cright); :}
;

//HIGHEST LEVEL
source ::=
  interface:i {: RESULT = (SourceFile) i; :}
| program:p {: RESULT = (SourceFile) p; :}
;

interface ::=
  func_decl:d {:
      ArrayList<FuncDecl> l = new ArrayList<>();
      l.add(d);
      RESULT = new InterfaceFile(l, dleft, dright); :}
| interface:i func_decl:d {: i.addFuncDecl(d); RESULT = i; :}
;

program ::=
importlist:il func_defnlist:dl {: RESULT = new ProgramFile(il, dl, illeft, ilright); :}
| func_defnlist:dl {:
    RESULT = new ProgramFile(new ArrayList<UseInterface>(), dl, dlleft, dlright); :}
;









